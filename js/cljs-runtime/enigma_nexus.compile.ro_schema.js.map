{"version":3,"sources":["enigma_nexus/compile/ro_schema.cljs"],"mappings":"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","names":["enigma-nexus.compile.ro-schema/decompile-from-tree","data","cljs.core/vector?","cljs.core.mapv","item","cljs.core/map?","cljs.core.apply","cljs.core/merge","cljs.core.map","p__70409","vec__70410","cljs.core.nth","key","value","cljs.core/coll?","enigma-nexus.compile.ro-schema/compile-to-tree","cljs.core/random-uuid","enigma-nexus.tree.ro.skins/cell-text-input","enigma-nexus.tree.ro.skins/expand-collapse","p__70442","vec__70443","enigma-nexus.compile.ro-schema/compile-basic-to-table","enigma-nexus.table.skins/cell-text-input","enigma-nexus.compile.ro-schema/_compile-item-to-table","enigma-nexus.table.skins/table-in-table","enigma-nexus.compile.ro-schema/compile-to-table","cljs.core/set?","cljs.core.merge","row","cljs.core/keys","cljs.core/vals","enigma-nexus.compile.ro-schema/compile-to-tree-table","cljs.core/Keyword","cljs.core/count","cljs.core/vec","cljs.core.map_indexed","index","enigma-nexus.tree.ro.skins/table-in-tree","p__70493","vec__70494","enigma-nexus.compile.ro-schema/decompile-array-columns","columns","cell","G__70498","js/Error","G__70511","enigma-nexus.compile.ro-schema/decompile-array-from-table","tabledata","rows","js/console.log","cljs.core/clj->js","p__70517","map__70519","cljs.core/--destructure-map","cljs.core.get","type","G__70521","cljs.core/first","enigma-nexus.compile.ro-schema/decompile-map-from-table","vec__70535","keys-row","values-row","keys","values","G__70545","G__70546","enigma-nexus.compile.ro-schema/decompile-from-table","G__70552","cljs.core.get_in"],"sourcesContent":["(ns enigma-nexus.compile.ro-schema\r\n  (:require\r\n   [reagent.core :as r :refer [with-let]]\r\n;   [enigma-nexus.compile.rw-schema :refer [compile-to-table]]\r\n   [enigma-nexus.table.skins :as table-skin]\r\n   [enigma-nexus.tree.ro.skins :as tree-skin]\r\n   [enigma-nexus.table.table :refer [table]]\r\n   [enigma-nexus.tree.icons :as icons]))\r\n\r\n(declare compile-to-tree)\r\n(declare compile-to-tree-table)\r\n\r\n(defn decompile-from-tree [data]\r\n  (cond\r\n    (vector? (:data data)) (mapv (fn [item] (decompile-from-tree item)) (:data data))\r\n    (map? (:data data)) (apply merge (map (fn [[key value]] {(decompile-from-tree key) (decompile-from-tree value)}) (:data data)))\r\n    (not (coll? (:data data))) (:data data)))\r\n\r\n(defn compile-to-tree [data]\r\n  (cond\r\n    (not (coll? data)) {:id (str (random-uuid))\r\n                        :indicators #{:expanded}\r\n                        :type :scalar\r\n                        :data (str data)\r\n                        :component [tree-skin/cell-text-input]} ; we need to be able w/o compilatation build a table widget that will present scalar\r\n\r\n    (vector? data)  {:id (str (random-uuid))\r\n                     :type :vector\r\n                     :indicators #{:expanded}\r\n                     :component [tree-skin/expand-collapse]\r\n                     :data (mapv (fn [item] (compile-to-tree item)) data)}\r\n\r\n    (map? data) {:id (str (random-uuid))\r\n                 :indicators #{:expanded}\r\n                 :type :map\r\n                 :component [tree-skin/expand-collapse]\r\n                 :data (apply merge (map (fn [[key item]] {{:indicators #{:expanded}\r\n                                                            :type :map-key\r\n                                                            :data (str key)\r\n                                                            :id (str (random-uuid))\r\n                                                            :component [tree-skin/cell-text-input tree-skin/expand-collapse]}\r\n                                                           (compile-to-tree item)}) data))}))\r\n\r\n\r\n\r\n(declare compile-map-to-table)\r\n(declare compile-vector-to-table)\r\n(declare compile-set-to-table)\r\n(declare compile-scalar-to-table)\r\n(declare compile-to-table)\r\n\r\n(defn compile-basic-to-table [data]\r\n  {:component [table-skin/cell-text-input]\r\n   :indicators #{}\r\n   :type :keyword\r\n   :data (str data)\r\n   :id (str (random-uuid))})\r\n\r\n\r\n(defn _compile-item-to-table [data]\r\n\t(cond\r\n   (vector? data) {:component [table-skin/table-in-table]\r\n                   :data (compile-to-table data)\r\n                   :type :vector\r\n                   :id (str (random-uuid))\r\n                   :indicators #{}}\r\n\r\n   (map? data) {:component [table-skin/table-in-table]\r\n                :data (compile-to-table data)\r\n                :type :map\r\n                :id (str (random-uuid))\r\n                :indicators #{}}\r\n   (set? data) {:component [table-skin/table-in-table]\r\n                :data (compile-to-table data)\r\n                :type :set\r\n                :id (str (random-uuid))\r\n                :indicators #{}}\r\n   :else {:component [table-skin/cell-text-input]\r\n          :indicators #{}\r\n          :type :keyword\r\n          :data (str data)\r\n          :id (str (random-uuid))}))\r\n\r\n(defn compile-to-table [data]\r\n  (merge {:id (str (random-uuid))\r\n          :expanded true\r\n          :indicators #{}\r\n          :component [table-skin/table-in-table]}\r\n         (cond\r\n           (not (coll? data)) {:type :scalar\r\n                               :data [{:id (str (random-uuid))\r\n                                       :data [(_compile-item-to-table data)]}]}\r\n\r\n           (vector? data)  {:type :vector\r\n                            :data (mapv (fn [row]\r\n                                          {:id (str (random-uuid))\r\n                                           :type (if (vector? row) :vector :row-single)\r\n                                           :data (mapv _compile-item-to-table (if (vector? row) row [row]))}) data)}\r\n\r\n           (map? data) {:type :map\r\n                        :data [{:id (str (random-uuid))\r\n                                :data (mapv compile-basic-to-table (keys data))\r\n                                :indicators #{}}\r\n                               {:id (str (random-uuid))\r\n                                :data (mapv _compile-item-to-table (vals data))\r\n                                :indicators #{}}]}\r\n           \r\n           (set? data) {:type :set\r\n                        :data [{:id (str (random-uuid))\r\n                                :data (mapv _compile-item-to-table data)\r\n                                :indicators #{}}]})))\r\n\r\n\r\n(declare compile-to-tree-table)\r\n\r\n\r\n\r\n\r\n(defn compile-to-tree-table [data]\r\n  (cond\r\n    (not (coll? data)) {:id (str (random-uuid))\r\n                        :indicators #{:expanded}\r\n                        :type :scalar\r\n                        :data (if (keyword? data) (str data) data)\r\n                        :component [tree-skin/cell-text-input]}\r\n\r\n    (and (vector? data) (< (count data) 2)) {:id (str (random-uuid))\r\n                                             :type :vector\r\n                                             :indicators #{:expanded}\r\n                                             :traversing :tree\r\n                                             :component [tree-skin/expand-collapse]\r\n                                             :data (vec (map-indexed (fn [index item] (compile-to-tree-table item)) data))}\r\n\r\n    (vector? data) {:id (str (random-uuid))\r\n                    :type :vector\r\n                    :component-hint \"table-in-tree\"\r\n                    :indicators #{:expanded :q}\r\n                    :component [tree-skin/table-in-tree]\r\n                    :traversing :table\r\n                    :data (compile-to-table data)}\r\n\r\n    (map? data) {:id (str (random-uuid))\r\n                 :indicators #{:expanded}\r\n                 :type :map\r\n                 :traversing :tree\r\n                 :component [tree-skin/expand-collapse]\r\n                 :data (apply merge (map (fn [[key item]] {{:indicators #{:expanded}\r\n                                                            :type :map-key\r\n                                                            :data (if (keyword? key) (str key) key)\r\n                                                            :id (str (random-uuid))\r\n                                                            :component [tree-skin/cell-text-input tree-skin/expand-collapse]}\r\n                                                            (compile-to-tree-table item)}) data))}))\r\n\r\n\r\n\r\n(declare decompile-array-from-table)\r\n(defn decompile-array-columns [columns]\r\n  (mapv (fn [cell] (case (:type cell)\r\n                     :vector (decompile-array-from-table (:data cell))\r\n                     :keyword (:data cell)\r\n                     :scalar (:data cell))) columns))\r\n\r\n\r\n(defn decompile-array-from-table [tabledata]\r\n  (let [rows (:rows tabledata)]\r\n    (js/console.log (clj->js rows))\r\n    (mapv (fn [{:keys [columns type]}]\r\n            (case type\r\n              :vector (decompile-array-columns columns)\r\n              :row-single (first (decompile-array-columns columns)))) rows)))\r\n\r\n\r\n(defn decompile-map-from-table [tabledata]\r\n  (let [[keys-row values-row] (:data tabledata)\r\n        keys (:data keys-row)\r\n        values (:data values-row)]\r\n    \r\n    (apply merge (mapv (fn [key value]\r\n                         {(:data key)\r\n                          (case (:type value)\r\n                            :vector (decompile-array-from-table (:data value))\r\n                            :map (decompile-map-from-table (:data value))\r\n                            :scalar (:data value)\r\n                            :keyword (:data value))}) keys values))))\r\n\r\n(defn decompile-from-table [tabledata]\r\n  (case (:type tabledata)\r\n    :scalar (get-in tabledata [:data 0 :data 0 :data])\r\n    :vector (decompile-array-from-table tabledata)\r\n    :map (decompile-map-from-table tabledata)))\r\n\r\n\r\n\r\n; (js/console.log (clj->js (compile-to-tree-table {:a 10 :b [1 2 3]})))\r\n; (js/console.log (clj->js (compile-to-tree-table {:a 10\r\n;                                                  :b [[:title :summary]\r\n;                                                      [\"one\" \"two\"]\r\n;                                                      [\"three\" \"four\"]]})))"]}