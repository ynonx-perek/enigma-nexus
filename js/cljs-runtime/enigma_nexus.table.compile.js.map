{"version":3,"sources":["enigma_nexus/table/compile.cljs"],"mappings":"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","names":["enigma-nexus.table.compile/compile-scalar-to-table","data","cljs.core/random-uuid","cljs.core/Keyword","enigma-nexus.table.skins/text-cell","enigma-nexus.table.compile/compile-array-to-table-bfs","cljs.core.mapv","row","value","cljs.core/vector?","enigma-nexus.table.skins/table-in-table","cljs.core/map?","enigma-nexus.table.compile/compile-map-to-table-bfs","enigma-nexus.table.compile/compile-set-to-table-bfs","key","cljs.core/keys","cljs.core/set?","cljs.core/vals","enigma-nexus.table.compile/compile-array-to-table-dfs","index","cljs.core.range","cljs.core/count","enigma-nexus.table.skins/tree-in-table","enigma-nexus.table.compile/compile-to-tree-table","enigma-nexus.table.compile/compile-set-to-table-dfs","enigma-nexus.table.compile/compile-map-to-table-dfs","enigma-nexus.table.compile/compile-to-table","cljs.core/coll?","enigma-nexus.table.compile/decompile-from-table","table","enigma-nexus.table.compile/my-vector","enigma-nexus.table.compile/compiled-my-vector","enigma-nexus.table.compile/decompile-from-tree","tree","item","cljs.core.apply","cljs.core/merge","cljs.core.map","p__60939","vec__60940","cljs.core.nth","enigma-nexus.table.compile/compile-to-tree","enigma-nexus.tree.skins/cell-text-input","enigma-nexus.tree.skins/expand-collapse","cljs.core/vec","cljs.core.map_indexed","p__60951","vec__60952","enigma-nexus.tree.skins/table-in-tree","p__60959","vec__60964"],"sourcesContent":["(ns enigma-nexus.table.compile\r\n  (:require\r\n   [reagent.core :as r :refer [with-let]]\r\n   [enigma-nexus.tree.skins :as tree-skin]\r\n   [enigma-nexus.table.skins :refer [text-cell table-in-table tree-in-table]]\r\n   [enigma-nexus.tree.icons :as icons]))\r\n\r\n(declare compile-map-to-table-bfs)\r\n(declare compile-to-tree)\r\n(declare compile-to-tree-table)\r\n\r\n\r\n(defn compile-scalar-to-table [data]\r\n  {:id (str (random-uuid))\r\n   :type :scalar\r\n   :expanded true\r\n   :rows [{:id (str (random-uuid))\r\n           :columns [(cond (keyword? data) {:component [text-cell]\r\n                                            :type :keyword\r\n                                            :content (str data)\r\n                                            :id (str (random-uuid))\r\n                                            :indicators #{}}\r\n\r\n                           :else {:component [text-cell]\r\n                                  :type :str\r\n                                  ;; TODO what about number?\r\n                                  :content data\r\n                                  :id (str (random-uuid))\r\n                                  :indicators #{}})]}]})\r\n\r\n(defn compile-array-to-table-bfs [data]\r\n  {:id (str (random-uuid))\r\n   :expanded true\r\n   :rows (mapv (fn [row]\r\n                 {:id (str (random-uuid))\r\n                  :columns (mapv (fn [value]\r\n                                   (cond\r\n                                     (vector? value) {:component [table-in-table]\r\n                                                      :content (compile-array-to-table-bfs value)\r\n                                                      :id (str (random-uuid))\r\n                                                      :indicators #{}}\r\n                                     (map? value) {:component [table-in-table]\r\n                                                   :content (compile-map-to-table-bfs value)\r\n                                                   :id (str (random-uuid))\r\n                                                   :indicators #{}}\r\n\r\n                                     (keyword? value) {:component [text-cell]\r\n                                                       :content (str value)\r\n                                                       :id (str (random-uuid))\r\n                                                       :indicators #{}}\r\n\r\n                                     :else {:component [text-cell]\r\n                                            :content value\r\n                                            :id (str (random-uuid))\r\n                                            :indicators #{}}))\r\n                                 (if (vector? row) row [row]))}) data)})\r\n\r\n\r\n\r\n(defn compile-set-to-table-bfs [data]\r\n  {:id (str (random-uuid))\r\n   :expanded true\r\n   :rows [{:id (str (random-uuid))\r\n           :columns (mapv (fn [value]\r\n                            {:component [text-cell]\r\n                             :content (cond\r\n                                        (keyword? value) (str value)\r\n                                        :else value)\r\n                             :id (str (random-uuid))\r\n                             :indicators #{}})\r\n                          data)}]})\r\n\r\n(defn compile-map-to-table-bfs [data]\r\n  {:id (str (random-uuid))\r\n   :expanded true\r\n   :rows [{:id (str (random-uuid))\r\n           :columns (mapv (fn [key]\r\n                            {:component [text-cell]\r\n                             :content (cond\r\n                                        (keyword? key) (str key)\r\n                                        :else key)\r\n                             :id (str (random-uuid))\r\n                             :indicators #{}})\r\n                          (keys data))}\r\n\r\n          {:id (str (random-uuid))\r\n           :columns (mapv (fn [value]\r\n                            (cond\r\n                              (vector? value) {:component [table-in-table]\r\n                                               :content (compile-array-to-table-bfs value)\r\n                                               :id (str (random-uuid))\r\n                                               :indicators #{}}\r\n                              (map? value) {:component [table-in-table]\r\n                                            :content (compile-map-to-table-bfs value)\r\n                                            :id (str (random-uuid))\r\n                                            :indicators #{}}\r\n                              (set? value) {:component [table-in-table]\r\n                                            :content (compile-set-to-table-bfs value)\r\n                                            :id (str (random-uuid))\r\n                                            :indicators #{}}\r\n                              (keyword? value) {:component [text-cell]\r\n                                                :content (str value)\r\n                                                :id (str (random-uuid))\r\n                                                :indicators #{}}\r\n                              :else {:component [text-cell]\r\n                                     :content value\r\n                                     :id (str (random-uuid))\r\n                                     :indicators #{}}))\r\n                          (vals data))}]})\r\n\r\n\r\n\r\n;;;;;;;;;;;;;;;;;;;;;;\r\n\r\n(declare compile-map-to-table-dfs)\r\n\r\n(defn compile-array-to-table-dfs [data]\r\n  {:id (str (random-uuid))\r\n   :expanded true\r\n   :type :vector\r\n   :rows [{:id (str (random-uuid))\r\n           :columns (mapv (fn [index]\r\n                            {:component [text-cell]\r\n                             :content index\r\n                             :id (str (random-uuid))\r\n                             :indicators #{}})\r\n                          (range (count data)))}\r\n\r\n          {:id (str (random-uuid))\r\n           :columns (mapv (fn [value]\r\n                            (cond\r\n                              (vector? value) {:component [table-in-table]\r\n                                               :content (compile-array-to-table-dfs value)\r\n                                               :id (str (random-uuid))\r\n                                               :indicators #{}}\r\n\r\n                              (map? value) {:component [tree-in-table]\r\n                                            :content (compile-to-tree-table value)\r\n                                            :id (str (random-uuid))\r\n                                            :indicators #{}}\r\n\r\n                              (keyword? value) {:component [text-cell]\r\n                                                :content (str value)\r\n                                                :id (str (random-uuid))\r\n                                                :indicators #{}}\r\n\r\n                              :else {:component [text-cell]\r\n                                     :content value\r\n                                     :id (str (random-uuid))\r\n                                     :indicators #{}}))\r\n                          data)}]})\r\n\r\n\r\n\r\n(defn compile-set-to-table-dfs [data]\r\n  {:id (str (random-uuid))\r\n   :expanded true\r\n   :type :set\r\n   :rows [{:id (str (random-uuid))\r\n           :columns (mapv (fn [value]\r\n                            {:component [text-cell]\r\n                             :content (cond\r\n                                        (keyword? value) (str value)\r\n                                        :else value)\r\n                             :id (str (random-uuid))\r\n                             :indicators #{}})\r\n                          data)}]})\r\n\r\n(defn compile-map-to-table-dfs [data]\r\n  {:id (str (random-uuid))\r\n   :type :map\r\n   :expanded true\r\n   :rows [{:id (str (random-uuid))\r\n           :columns (mapv (fn [key]\r\n                            {:component [text-cell]\r\n                             :content (cond\r\n                                        (keyword? key) (str key)\r\n                                        :else key)\r\n                             :id (str (random-uuid))\r\n                             :indicators #{}})\r\n                          (keys data))}\r\n\r\n          {:id (str (random-uuid))\r\n           :columns (mapv (fn [value]\r\n                            (cond\r\n                              (vector? value) {:component [table-in-table]\r\n                                               :content (compile-array-to-table-dfs value)\r\n                                               :id (str (random-uuid))\r\n                                               :indicators #{}}\r\n                              (map? value) {:component [table-in-table]\r\n                                            :content (compile-map-to-table-dfs value)\r\n                                            :id (str (random-uuid))\r\n                                            :indicators #{}}\r\n                              (set? value) {:component [table-in-table]\r\n                                            :content (compile-set-to-table-dfs value)\r\n                                            :id (str (random-uuid))\r\n                                            :indicators #{}}\r\n                              (keyword? value) {:component [text-cell]\r\n                                                :content (str value)\r\n                                                :id (str (random-uuid))\r\n                                                :indicators #{}}\r\n                              :else {:component [text-cell]\r\n                                     :content value\r\n                                     :id (str (random-uuid))\r\n                                     :indicators #{}}))\r\n                          (vals data))}]})\r\n\r\n\r\n\r\n(defn compile-to-table [data]\r\n  (cond\r\n    (not (coll? data)) (compile-scalar-to-table data)\r\n    (vector? data) (compile-array-to-table-dfs data)\r\n    (map? data) (compile-map-to-table-dfs data)))\r\n\r\n\r\n\r\n\r\n\r\n(defn decompile-from-table [table])\r\n\r\n;; (defn split-vector-at-keys-change [data]\r\n;;   (partition-by\r\n;;    (fn [item]\r\n;;      (cond\r\n;;        (map? item) (keys item)\r\n;;        :else item)) data))\r\n\r\n\r\n;; (defn compile-vector-of-records-to-table [data]\r\n;;   (let [groups-of-records (split-vector-at-keys-change data)]\r\n;;     (mapv (fn [group]\r\n;;             (cond\r\n;;               (map? (first group)) (compile-records-to-table group)\r\n;;               :else (compile-single-row group))) groups-of-records)))\r\n\r\n;; (defn compile-to-table-of-records [data]\r\n;;   (cond\r\n;;     (not (coll? data)) (compile-scalar-to-table data)\r\n;;     (vector? data) (compile-vector-of-records-to-table data)))\r\n\r\n(def my-vector [{:a 1 :b 2}\r\n                {:a 3 :b 4}\r\n                {:a 5 :b 6}\r\n                12\r\n                {:c 7 :d 8}\r\n                {:c 9 :d 10}\r\n                24\r\n                {:e 11 :f 12}])\r\n\r\n\r\n(def compiled-my-vector {:rows [{:columns [\"a\" \"b\"]}\r\n                                {:columns [1 2]}\r\n                                {:columns [3 4]}\r\n                                {:columns [5 6]}\r\n                                {:columns [\"Scalar?\"]}\r\n                                {:columns [12]}\r\n                                {:columns [\"c d\"]}\r\n                                {:columns [7 8]}\r\n                                {:columns [9 10]}\r\n                                {:columns [\"Scalar?\"]}\r\n                                {:columns [24]}\r\n                                {:columns [\"e f\"]}\r\n                                {:columns [11 12]}]})\r\n\r\n\r\n;; (js/console.log (clj->js (split-vector-at-keys-change my-vector)))\r\n\r\n\r\n\r\n;; (js/console.log (clj->js (compile-to-table {:a 10 :b 20})))\r\n;; (js/console.log (clj->js (split-on-key-change [{:a 10 :b 20}\r\n;;                                                12\r\n;;                                                {:a 17 :b 28}\r\n;;                                                {:a 17 :b 28}\r\n;;                                                {:a 17 :b 28}\r\n;;                                                24\r\n;;                                                {:a 20 :b 99}])))\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n;; (defn decompile-table-vector [tablevector]\r\n;;   )\r\n\r\n\r\n;; (defn decompile-from-table [tabledata]\r\n;;   (case (:type tabledata)\r\n;;     :vector (decompile-table-vector tabledata)\r\n;;     :map (decompile-table-map tabledata)\r\n;;     :set (decompile-table-set tabledata)\r\n;;     :scalar (decompile-table-scalar tabledata)))\r\n\r\n\r\n;; {:id (str (random-uuid))\r\n;;  :class \"main-tree\"\r\n;;  :value \"Task 2\"\r\n;;  :component [text-cell expand-collapse]\r\n;;  :indicators #{:expanded}\r\n;;  :tree [{:value \"Task 2.1\"\r\n;;          :id (str (random-uuid))\r\n;;          :indicators #{}\r\n;;          :component [text-cell expand-collapse]\r\n;;          :tree [{:value \"Task 2.1.1\"\r\n;;                  :indicators #{}\r\n;;                  :id (str (random-uuid))\r\n;;                  :component [text-cell expand-collapse]\r\n;;                  :tree [{:value \"document.txt\"\r\n;;                          :indicators #{}\r\n;;                          :id (str (random-uuid))\r\n;;                          :component [text-cell document-leaf]}\r\n;;                         {:value \"proposal.txt\"\r\n;;                          :indicators #{}\r\n;;                          :id (str (random-uuid))\r\n;;                          :component [text-cell document-leaf]}]}]}\r\n\r\n;;         {:value \"Task 2.2\"\r\n;;          :indicators #{}\r\n;;          :id (str (random-uuid))\r\n;;          :component [text-cell]}]}\r\n\r\n;; (defn map-to-tree [data]\r\n;;   {:id (str (random-uuid))\r\n;;    :value \"\"\r\n;;    :indicators #{:expanded}\r\n;;    :component [text-cell]\r\n;;    :tree [(mapv (fn [item] (cond\r\n;;                              (vector? item) {:value (array-to-tree item)\r\n;;                                              :indicators #{}\r\n;;                                              :id (str (random-uuid))\r\n;;                                              :component [tree]}\r\n\r\n;;                              (map? item) {:value (map-to-tree item)\r\n;;                                           :indicators #{}\r\n;;                                           :id (str (random-uuid))\r\n;;                                           :component [tree]}\r\n\r\n;;                              (set? item) {:value (set-to-tree item)\r\n;;                                           :indicators #{}\r\n;;                                           :id (str (random-uuid))\r\n;;                                           :component [tree]}\r\n\r\n;;                              :else {:value item\r\n;;                                     :indicators #{}\r\n;;                                     :id (str (random-uuid))\r\n;;                                     :component [text-cell document-leaf]})) data)]})\r\n\r\n\r\n\r\n(defn decompile-from-tree [tree]\r\n  (cond\r\n    (vector? (:tree tree)) (mapv (fn [item] (decompile-from-tree item)) (:tree tree))\r\n    (map? (:tree tree)) (apply merge (map (fn [[key value]] {(decompile-from-tree key) (decompile-from-tree value)}) (:tree tree)))\r\n    (not (coll? (:tree tree))) (:tree tree)))\r\n\r\n\r\n; (defn compile-to-tree [data]\r\n;   (cond\r\n;     (not (coll? data)) {:id (str (random-uuid))\r\n;                         :indicators #{:expanded}\r\n;                         :type :scalar\r\n;                         :value (if (keyword? data) (str data) data)\r\n;                         :component [cell-text-input]}\r\n\r\n;     (vector? data) {:id (str (random-uuid))\r\n;                     :indicators #{:expanded}\r\n;                     :type :vector\r\n;                     :component [cell-text-input]\r\n;                     :tree (vec (map-indexed (fn [index item] {:value index\r\n;                                                               :type :array-index\r\n;                                                               :indicators #{}\r\n;                                                               :tree [(compile-to-tree item)]\r\n;                                                               :id (str (random-uuid))\r\n;                                                               :component [cell-text-input expand-collapse]}) data))}\r\n\r\n\r\n;     (map? data) {:id (str (random-uuid))\r\n;                  :indicators #{:expanded}\r\n;                  :type :map\r\n;                  :component [cell-text-input]\r\n;                  :tree (vec (map (fn [[key item]] {:value (if (keyword? key) (str key) key)\r\n;                                                    :indicators #{}\r\n;                                                    :type :map-key\r\n;                                                    :tree [(compile-to-tree item)]\r\n;                                                    :id (str (random-uuid))\r\n;                                                    :component [cell-text-input expand-collapse]}) data))}))\r\n\r\n\r\n(defn compile-to-tree [data]\r\n  (cond\r\n    (not (coll? data)) {:id (str (random-uuid))\r\n                        :indicators #{:expanded}\r\n                        :type :scalar\r\n                        :tree (if (keyword? data) (str data) data)\r\n                        :component [tree-skin/cell-text-input]}\r\n\r\n    (vector? data) {:id (str (random-uuid))\r\n                    :type :vector\r\n                    :indicators #{:expanded}\r\n                    :component [tree-skin/expand-collapse]\r\n                    :tree (vec (map-indexed (fn [index item] (compile-to-tree item)) data))}\r\n\r\n    (map? data) {:id (str (random-uuid))\r\n                 :indicators #{:expanded}\r\n                 :type :map\r\n                 :component [tree-skin/expand-collapse]\r\n                 :tree (apply merge (map (fn [[key item]] {{:indicators #{:expanded}\r\n                                                            :type :map-key\r\n                                                            :tree (if (keyword? key) (str key) key)\r\n                                                            :id (str (random-uuid))\r\n                                                            :component [tree-skin/cell-text-input tree-skin/expand-collapse]}\r\n                                                           (compile-to-tree item)}) data))}))\r\n\r\n\r\n(defn compile-to-tree-table [data] \r\n  (cond\r\n    (not (coll? data)) {:id (str (random-uuid))\r\n                        :indicators #{:expanded}\r\n                        :type :scalar\r\n                        :tree (if (keyword? data) (str data) data)\r\n                        :component [tree-skin/cell-text-input]}\r\n\r\n    (and (vector? data) (< (count data) 2)) {:id (str (random-uuid))\r\n                                             :type :vector\r\n                                             :indicators #{:expanded}\r\n                                             :component [tree-skin/expand-collapse]\r\n                                             :tree (vec (map-indexed (fn [index item] (compile-to-tree-table item)) data))}\r\n\r\n    (vector? data) {:id (str (random-uuid))\r\n                    :type :vector\r\n                    :component-hint \"table-in-tree\"\r\n                    :indicators #{:expanded :q}\r\n                    :component [tree-skin/table-in-tree]\r\n                    :tree (compile-to-table data)}\r\n\r\n    (map? data) {:id (str (random-uuid))\r\n                 :indicators #{:expanded}\r\n                 :type :map\r\n                 :component [tree-skin/expand-collapse]\r\n                 :tree (apply merge (map (fn [[key item]] {{:indicators #{:expanded}\r\n                                                            :type :map-key\r\n                                                            :tree (if (keyword? key) (str key) key)\r\n                                                            :id (str (random-uuid))\r\n                                                            :component [tree-skin/cell-text-input tree-skin/expand-collapse]}\r\n                                                           (compile-to-tree-table item)}) data))}))\r\n"]}