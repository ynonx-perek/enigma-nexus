{"version":3,"sources":["enigma_nexus/compile/rw_schema.cljs"],"mappings":"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","names":["enigma-nexus.compile.rw-schema/decompile-from-tree","tree","G__62914","cljs.core/Keyword","js/Error","cljs.core.apply","cljs.core/merge","cljs.core.map","item","G__62915","cljs.core/first","cljs.core.mapv","G__62916","enigma-nexus.compile.rw-schema/compile-to-tree","data","cljs.core/coll?","cljs.core/random-uuid","enigma-nexus.tree.rw.skins/cell-text-input","enigma-nexus.tree.rw.skins/document-leaf","cljs.core/vector?","cljs.core/vec","cljs.core.map_indexed","index","enigma-nexus.tree.rw.skins/expand-collapse","cljs.core/map?","p__62917","vec__62918","cljs.core.nth","key","enigma-nexus.compile.rw-schema/compile-scalar-to-table","enigma-nexus.table.skins/text-cell","enigma-nexus.compile.rw-schema/compile-array-to-table","row","value","enigma-nexus.table.skins/table-in-table","enigma-nexus.compile.rw-schema/compile-map-to-table","enigma-nexus.compile.rw-schema/decompile-array-columns","columns","cell","G__62921","G__62922","enigma-nexus.compile.rw-schema/decompile-array-from-table","tabledata","rows","js/console.log","cljs.core/clj->js","p__62923","map__62924","cljs.core/--destructure-map","cljs.core.get","type","G__62925","enigma-nexus.compile.rw-schema/compile-set-to-table","cljs.core/keys","cljs.core/set?","cljs.core/vals","enigma-nexus.compile.rw-schema/decompile-map-from-table","vec__62926","keys-row","values-row","keys","values","G__62929","G__62930","enigma-nexus.compile.rw-schema/compile-to-table","enigma-nexus.compile.rw-schema/decompile-from-table","G__62931","cljs.core.get_in"],"sourcesContent":["(ns enigma-nexus.compile.rw-schema\r\n  (:require \r\n   [reagent.core :as r :refer [with-let]] \r\n   [enigma-nexus.table.skins :as table-skin]\r\n   [enigma-nexus.tree.rw.skins :as tree-skin]\r\n   [enigma-nexus.table.table :refer [table]]\r\n   [enigma-nexus.tree.icons :as icons]))\r\n\r\n(defn decompile-from-tree [tree]\r\n  (case (:type tree)\r\n    :scalar (:value tree)\r\n    :map (apply merge (map (fn [item] {(:value item) (decompile-from-tree (first (:tree item)))}) (:tree tree)))\r\n    :vector (mapv (fn [item] (decompile-from-tree (first (:tree item)))) (:tree tree))))\r\n\r\n\r\n(defn compile-to-tree [data]\r\n  (cond\r\n    (not (coll? data)) {:id (str (random-uuid))\r\n                        :indicators #{:expanded}\r\n                        :type :scalar\r\n                        :value (if (keyword? data) (str data) data)\r\n                        :component [tree-skin/cell-text-input tree-skin/document-leaf]}\r\n\r\n    (vector? data) {:id (str (random-uuid))\r\n                    :indicators #{:expanded}\r\n                    :type :vector\r\n                    :component [tree-skin/cell-text-input]\r\n                    :tree (vec (map-indexed (fn [index item] {:value index\r\n                                                              :type :array-index\r\n                                                              :indicators #{}\r\n                                                              :tree [(compile-to-tree item)]\r\n                                                              :id (str (random-uuid))\r\n                                                              :component [tree-skin/cell-text-input tree-skin/expand-collapse]}) data))}\r\n\r\n\r\n    (map? data) {:id (str (random-uuid))\r\n                 :indicators #{:expanded}\r\n                 :type :map\r\n                 :component [tree-skin/cell-text-input]\r\n                 :tree (vec (map (fn [[key item]] {:value (if (keyword? key) (str key) key)\r\n                                                   :indicators #{}\r\n                                                   :type :map-key\r\n                                                   :tree [(compile-to-tree item)]\r\n                                                   :id (str (random-uuid))\r\n                                                   :component [tree-skin/cell-text-input tree-skin/expand-collapse]}) data))}))\r\n\r\n(declare compile-map-to-table)\r\n\r\n\r\n(defn compile-scalar-to-table [data]\r\n  {:id (str (random-uuid))\r\n   :type :scalar\r\n   :expanded true\r\n   :rows [{:id (str (random-uuid))\r\n           :columns [(cond (keyword? data) {:component [table-skin/text-cell]\r\n                                            :type :keyword\r\n                                            :content (str data)\r\n                                            :id (str (random-uuid))\r\n                                            :indicators #{}}\r\n\r\n                           :else {:component [table-skin/text-cell]\r\n                                  :type :str\r\n                                  ;; TODO what about number?\r\n                                  :content data\r\n                                  :id (str (random-uuid))\r\n                                  :indicators #{}})]}]})\r\n\r\n(defn compile-array-to-table [data]\r\n  {:id (str (random-uuid))\r\n   :type :vector\r\n   :expanded true\r\n   :rows (mapv (fn [row]\r\n                 {:id (str (random-uuid))\r\n                  :type (if (vector? row) :vector :row-single)\r\n                  :columns (mapv (fn [value]\r\n                                   (cond\r\n                                     (vector? value) {:component [table-skin/table-in-table]\r\n                                                      :content (compile-array-to-table value)\r\n                                                      :type :vector\r\n                                                      :id (str (random-uuid))\r\n                                                      :indicators #{}}\r\n                                     \r\n                                     (map? value) {:component [table-skin/table-in-table]\r\n                                                   :content (compile-map-to-table value)\r\n                                                   :type :map\r\n                                                   :id (str (random-uuid))\r\n                                                   :indicators #{}}\r\n\r\n                                     (keyword? value) {:component [table-skin/text-cell]\r\n                                                       :content (str value)\r\n                                                       :type :keyword\r\n                                                       :id (str (random-uuid))\r\n                                                       :indicators #{}}\r\n\r\n                                     :else {:component [table-skin/text-cell]\r\n                                            :content value\r\n                                            :type :scalar\r\n                                            :id (str (random-uuid))\r\n                                            :indicators #{}}))\r\n                                 (if (vector? row) row [row]))}) data)})\r\n\r\n(declare decompile-array-from-table)\r\n(defn decompile-array-columns [columns]\r\n  (mapv (fn [cell] (case (:type cell)\r\n                     :vector (decompile-array-from-table (:content cell))\r\n                     :keyword (:content cell)\r\n                     :scalar (:content cell))) columns))\r\n\r\n(defn decompile-array-from-table [tabledata]\r\n  (let [rows (:rows tabledata)]\r\n    (js/console.log (clj->js rows))\r\n    (mapv (fn [{:keys [columns type]}]\r\n            (case type\r\n              :vector (decompile-array-columns columns)\r\n              :row-single (first (decompile-array-columns columns)))) rows)))\r\n\r\n\r\n(defn compile-set-to-table [data]\r\n  {:id (str (random-uuid))\r\n   :expanded true\r\n   :type :set\r\n   :rows [{:id (str (random-uuid))\r\n           :columns (mapv (fn [value]\r\n                            {:component [table-skin/text-cell]\r\n                             :content (cond\r\n                                        (keyword? value) (str value)\r\n                                        :else value)\r\n                             :id (str (random-uuid))\r\n                             :indicators #{}})\r\n                          data)}]})\r\n\r\n(defn compile-map-to-table [data]\r\n  {:id (str (random-uuid))\r\n   :expanded true\r\n   :type :map\r\n   :rows [{:id (str (random-uuid))\r\n           :columns (mapv (fn [key]\r\n                            {:component [table-skin/text-cell] \r\n                             :content (cond\r\n                                        (keyword? key) (str key)\r\n                                        :else key)\r\n                             :id (str (random-uuid))\r\n                             :indicators #{}})\r\n                          (keys data))}\r\n\r\n          {:id (str (random-uuid))\r\n           :columns (mapv (fn [value]\r\n                            (cond\r\n                              (vector? value) {:component [table-skin/table-in-table]\r\n                                               :content (compile-array-to-table value)\r\n                                               :type :vector\r\n                                               :id (str (random-uuid))\r\n                                               :indicators #{}}\r\n                              (map? value) {:component [table-skin/table-in-table]\r\n                                            :content (compile-map-to-table value)\r\n                                            :type :map\r\n                                            :id (str (random-uuid))\r\n                                            :indicators #{}}\r\n                              (set? value) {:component [table-skin/table-in-table]\r\n                                            :content (compile-set-to-table value)\r\n                                            :type :set\r\n                                            :id (str (random-uuid))\r\n                                            :indicators #{}}\r\n                              (keyword? value) {:component [table-skin/text-cell]\r\n                                                :content (str value)\r\n                                                :type :keyword\r\n                                                :id (str (random-uuid))\r\n                                                :indicators #{}}\r\n                              :else {:component [table-skin/text-cell]\r\n                                     :content value\r\n                                     :type :scalar\r\n                                     :id (str (random-uuid))\r\n                                     :indicators #{}}))\r\n                          (vals data))}]})\r\n\r\n(defn decompile-map-from-table [tabledata]\r\n  (let [[keys-row values-row] (:rows tabledata)\r\n        keys (:columns keys-row)\r\n        values (:columns values-row)]\r\n    \r\n    (apply merge (mapv (fn [key value]\r\n                         {(:content key)\r\n                          (case (:type value)\r\n                            :vector (decompile-array-from-table (:content value))\r\n                            :map (decompile-map-from-table (:content value))\r\n                            :scalar (:content value)\r\n                            :keyword (:content value))}) keys values))))\r\n\r\n(defn compile-to-table [data]\r\n  (cond\r\n    (not (coll? data)) (compile-scalar-to-table data)\r\n    (vector? data) (compile-array-to-table data)\r\n    (map? data) (compile-map-to-table data)))\r\n\r\n\r\n(defn decompile-from-table [tabledata]\r\n  (case (:type tabledata)\r\n    :scalar (get-in tabledata [:rows 0 :columns 0 :content])\r\n    :vector (decompile-array-from-table tabledata)\r\n    :map (decompile-map-from-table tabledata)))\r\n\r\n;; (js/console.log (clj->js (decompile-from-table (compile-to-table 99))))\r\n(js/console.log (clj->js (decompile-from-table (compile-to-table {:a [10 20 30]}))))"]}