{"version":3,"sources":["enigma_nexus/compile/rw_schema.cljs"],"mappings":"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","names":["enigma-nexus.compile.rw-schema/decompile-from-tree","tree","G__61515","cljs.core/Keyword","js/Error","cljs.core.apply","cljs.core/merge","cljs.core.map","item","G__61519","cljs.core/first","cljs.core.mapv","G__61528","enigma-nexus.compile.rw-schema/compile-to-tree","data","cljs.core/coll?","cljs.core/random-uuid","enigma-nexus.tree.rw.skins/cell-text-input","enigma-nexus.tree.rw.skins/document-leaf","cljs.core/vector?","cljs.core/vec","cljs.core.map_indexed","index","enigma-nexus.tree.rw.skins/expand-collapse","cljs.core/map?","p__61543","vec__61545","cljs.core.nth","key","enigma-nexus.compile.rw-schema/compile-scalar-to-table","enigma-nexus.table.skins/text-cell","enigma-nexus.compile.rw-schema/compile-array-to-table","row","value","enigma-nexus.table.skins/table-in-table","enigma-nexus.compile.rw-schema/compile-map-to-table","enigma-nexus.compile.rw-schema/decompile-array-columns","columns","cell","G__61573","G__61576","enigma-nexus.compile.rw-schema/decompile-array-from-table","tabledata","rows","js/console.log","cljs.core/clj->js","p__61583","map__61584","cljs.core/--destructure-map","cljs.core.get","type","G__61586","enigma-nexus.compile.rw-schema/compile-set-to-table","cljs.core/keys","cljs.core/set?","cljs.core/vals","enigma-nexus.compile.rw-schema/decompile-map-from-table","vec__61613","keys-row","values-row","keys","values","G__61622","G__61623","enigma-nexus.compile.rw-schema/compile-to-table","enigma-nexus.compile.rw-schema/decompile-from-table","G__61634","cljs.core.get_in"],"sourcesContent":["(ns enigma-nexus.compile.rw-schema\r\n  (:require \r\n   [reagent.core :as r :refer [with-let]] \r\n   [enigma-nexus.table.skins :as table-skin]\r\n   [enigma-nexus.tree.rw.skins :as tree-skin]\r\n   [enigma-nexus.tree.icons :as icons]))\r\n\r\n(defn decompile-from-tree [tree]\r\n  (case (:type tree)\r\n    :scalar (:value tree)\r\n    :map (apply merge (map (fn [item] {(:value item) (decompile-from-tree (first (:tree item)))}) (:tree tree)))\r\n    :vector (mapv (fn [item] (decompile-from-tree (first (:tree item)))) (:tree tree))))\r\n\r\n\r\n(defn compile-to-tree [data]\r\n  (cond\r\n    (not (coll? data)) {:id (str (random-uuid))\r\n                        :indicators #{:expanded}\r\n                        :type :scalar\r\n                        :value (if (keyword? data) (str data) data)\r\n                        :component [tree-skin/cell-text-input tree-skin/document-leaf]}\r\n\r\n    (vector? data) {:id (str (random-uuid))\r\n                    :indicators #{:expanded}\r\n                    :type :vector\r\n                    :component [tree-skin/cell-text-input]\r\n                    :tree (vec (map-indexed (fn [index item] {:value index\r\n                                                              :type :array-index\r\n                                                              :indicators #{}\r\n                                                              :tree [(compile-to-tree item)]\r\n                                                              :id (str (random-uuid))\r\n                                                              :component [tree-skin/cell-text-input tree-skin/expand-collapse]}) data))}\r\n\r\n\r\n    (map? data) {:id (str (random-uuid))\r\n                 :indicators #{:expanded}\r\n                 :type :map\r\n                 :component [tree-skin/cell-text-input]\r\n                 :tree (vec (map (fn [[key item]] {:value (if (keyword? key) (str key) key)\r\n                                                   :indicators #{}\r\n                                                   :type :map-key\r\n                                                   :tree [(compile-to-tree item)]\r\n                                                   :id (str (random-uuid))\r\n                                                   :component [tree-skin/cell-text-input tree-skin/expand-collapse]}) data))}))\r\n\r\n(declare compile-map-to-table)\r\n\r\n\r\n(defn compile-scalar-to-table [data]\r\n  {:id (str (random-uuid))\r\n   :type :scalar\r\n   :expanded true\r\n   :data [{:id (str (random-uuid))\r\n           :data [(cond \r\n           \t\t\t\t\t\t\t\t\t\t\t\t\t\t\t(keyword? data) {:component [table-skin/text-cell]\r\n                                            :type :keyword\r\n                                            :data (str data)\r\n                                            :id (str (random-uuid))\r\n                                            :indicators #{}}\r\n\r\n                           :else {:component [table-skin/text-cell]\r\n                                  :type :str\r\n                                  :data data\r\n                                  :id (str (random-uuid))\r\n                                  :indicators #{}})]}]})\r\n\r\n(defn compile-array-to-table [data]\r\n  {:id (str (random-uuid))\r\n   :type :vector\r\n   :expanded true\r\n   :data (mapv (fn [row]\r\n                 {:id (str (random-uuid))\r\n                  :type (if (vector? row) :vector :row-single)\r\n                  :data (mapv (fn [value]\r\n                                   (cond\r\n                                     (vector? value) {:component [table-skin/table-in-table]\r\n                                                      :data (compile-array-to-table value)\r\n                                                      :type :vector\r\n                                                      :id (str (random-uuid))\r\n                                                      :indicators #{}}\r\n                                     \r\n                                     (map? value) {:component [table-skin/table-in-table]\r\n                                                   :data (compile-map-to-table value)\r\n                                                   :type :map\r\n                                                   :id (str (random-uuid))\r\n                                                   :indicators #{}}\r\n\r\n                                     (keyword? value) {:component [table-skin/text-cell]\r\n                                                       :data (str value)\r\n                                                       :type :keyword\r\n                                                       :id (str (random-uuid))\r\n                                                       :indicators #{}}\r\n\r\n                                     :else {:component [table-skin/text-cell]\r\n                                            :data value\r\n                                            :type :scalar\r\n                                            :id (str (random-uuid))\r\n                                            :indicators #{}}))\r\n                                 (if (vector? row) row [row]))}) data)})\r\n\r\n(declare decompile-array-from-table)\r\n(defn decompile-array-columns [columns]\r\n  (mapv (fn [cell] (case (:type cell)\r\n                     :vector (decompile-array-from-table (:data cell))\r\n                     :keyword (:data cell)\r\n                     :scalar (:data cell))) columns))\r\n\r\n(defn decompile-array-from-table [tabledata]\r\n  (let [rows (:rows tabledata)]\r\n    (js/console.log (clj->js rows))\r\n    (mapv (fn [{:keys [columns type]}]\r\n            (case type\r\n              :vector (decompile-array-columns columns)\r\n              :row-single (first (decompile-array-columns columns)))) rows)))\r\n\r\n\r\n(defn compile-set-to-table [data]\r\n  {:id (str (random-uuid))\r\n   :expanded true\r\n   :type :set\r\n   :data [{:id (str (random-uuid))\r\n           :data (mapv (fn [value]\r\n                            {:component [table-skin/text-cell]\r\n                             :data (cond\r\n                                        (keyword? value) (str value)\r\n                                        :else value)\r\n                             :id (str (random-uuid))\r\n                             :indicators #{}})\r\n                          data)}]})\r\n\r\n(defn compile-map-to-table [data]\r\n  {:id (str (random-uuid))\r\n   :expanded true\r\n   :type :map\r\n   :data [{:id (str (random-uuid))\r\n           :data (mapv (fn [key]\r\n                            {:component [table-skin/text-cell] \r\n                             :data (cond\r\n                                        (keyword? key) (str key)\r\n                                        :else key)\r\n                             :id (str (random-uuid))\r\n                             :indicators #{}})\r\n                          (keys data))}\r\n\r\n          {:id (str (random-uuid))\r\n           :data (mapv (fn [value]\r\n                            (cond\r\n                              (vector? value) {:component [table-skin/table-in-table]\r\n                                               :data (compile-array-to-table value)\r\n                                               :type :vector\r\n                                               :id (str (random-uuid))\r\n                                               :indicators #{}}\r\n                              (map? value) {:component [table-skin/table-in-table]\r\n                                            :data (compile-map-to-table value)\r\n                                            :type :map\r\n                                            :id (str (random-uuid))\r\n                                            :indicators #{}}\r\n                              (set? value) {:component [table-skin/table-in-table]\r\n                                            :data (compile-set-to-table value)\r\n                                            :type :set\r\n                                            :id (str (random-uuid))\r\n                                            :indicators #{}}\r\n                              (keyword? value) {:component [table-skin/text-cell]\r\n                                                :data (str value)\r\n                                                :type :keyword\r\n                                                :id (str (random-uuid))\r\n                                                :indicators #{}}\r\n                              :else {:component [table-skin/text-cell]\r\n                                     :data value\r\n                                     :type :scalar\r\n                                     :id (str (random-uuid))\r\n                                     :indicators #{}}))\r\n                          (vals data))}]})\r\n\r\n(defn decompile-map-from-table [tabledata]\r\n  (let [[keys-row values-row] (:data tabledata)\r\n        keys (:data keys-row)\r\n        values (:data values-row)]\r\n    \r\n    (apply merge (mapv (fn [key value]\r\n                         {(:data key)\r\n                          (case (:type value)\r\n                            :vector (decompile-array-from-table (:data value))\r\n                            :map (decompile-map-from-table (:data value))\r\n                            :scalar (:data value)\r\n                            :keyword (:data value))}) keys values))))\r\n\r\n(defn compile-to-table [data]\r\n  (cond\r\n    (not (coll? data)) (compile-scalar-to-table data)\r\n    (vector? data) (compile-array-to-table data)\r\n    (map? data) (compile-map-to-table data)))\r\n\r\n\r\n(defn decompile-from-table [tabledata]\r\n  (case (:type tabledata)\r\n    :scalar (get-in tabledata [:data 0 :data 0 :data])\r\n    :vector (decompile-array-from-table tabledata)\r\n    :map (decompile-map-from-table tabledata)))\r\n\r\n;; (js/console.log (clj->js (decompile-from-table (compile-to-table 99))))\r\n;(js/console.log (clj->js (decompile-from-table (compile-to-table {:a [10 20 30]}))))"]}