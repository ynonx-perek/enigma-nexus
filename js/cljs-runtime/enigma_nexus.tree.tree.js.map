{"version":3,"sources":["enigma_nexus/tree/tree.cljs"],"mappings":"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","names":["enigma-nexus.tree.tree/map-tree-node","props","map__77760","cljs.core/--destructure-map","cljs.core.get","tree*","key","compilation-rules","with-let77761","reagent.ratom/with-let-values","temp__5808__auto__","reagent.ratom/*ratom-context*","c__59044__auto__","reagent.debug/has-console","reagent.debug/tracking","reagent.debug/track-console","js/console","init77762","cljs.core/not","res77763","my-tree*","reagent.core/cursor","expanded*","reagent.core.atom","cljs.core.swap_BANG_","cljs.core/deref","enigma-nexus.tree.tree/tree-widget","map__77764","index","with-let77765","init77766","res77767","indicators*","map__77768","id","class","value","component","indicators","cljs.core/contains?","cljs.core/vec","cljs.core.concat","cljs.core.map_indexed","c-index","c","child-node","enigma-nexus.tree.tree/node","with-let77769","init77770","res77771","map__77772","tree-options","nodes","type","style","expanded-style","expanded-class","cljs.core.merge","G__77773","cljs.core/Keyword","e","cljs.core/reset!","child-count","cljs.core/count","child","cljs.core.not_EQ_"],"sourcesContent":["(ns enigma-nexus.tree.tree\r\n  (:require\r\n   [reagent.core :as r :refer [with-let]]))\r\n\r\n;; (def demo-data-from-figma\r\n;;   {:class \"main-tree\"\r\n;;    :value \"Task 2\"\r\n;;    :component [text-cell expand-collapse]\r\n;;    :indicators #{:expanded}\r\n;;    :nodes [{:value \"Task 2.1\"\r\n;;             :component [text-cell expand-collapse]\r\n;;             :nodes [{:value \"Task 2.1.1\"\r\n;;                      :component [text-cell expand-collapse]\r\n;;                      :nodes [{:value \"document.txt\"\r\n;;                               :component [text-cell document-leaf]}\r\n;;                              {:value \"proposal.txt\"\r\n;;                               :component [text-cell document-leaf]}]}]}\r\n;;            {:value \"Task 2.2\"\r\n;;             :component [text-cell]}]})\r\n\r\n(declare tree-widget)\r\n\r\n(defn map-tree-node [props]\r\n  (let [{:keys [tree* key compilation-rules]} props]\r\n    (r/with-let [my-tree* (r/cursor tree* [key])\r\n                 expanded* (r/atom true)]\r\n      [:div {:class \"inner-tree-value\"\r\n             :style {:cusror \"pointer\"}\r\n             :on-click (fn [] (swap! expanded* not))} (str key (if @expanded* \" V\" \">\"))\r\n       \r\n       (if @expanded*\r\n         [tree-widget {:tree* my-tree*}])])))\r\n\r\n(comment (defn tree-widget [props]\r\n  (let [{:keys [tree* index compilation-rules]} props]\r\n    (r/with-let [my-tree* (r/cursor tree* (if index index []))]\r\n\r\n      [:div  {:class \"tree-node\"}\r\n       (cond\r\n         (not (coll? @my-tree*)) [:div {:class \"inner-tree-value\"}  @my-tree*]\r\n         \r\n         (vector? @my-tree*)  (doall (map-indexed (fn [index item]\r\n                                                    [map-tree-node {:tree* my-tree* :key index}]) @my-tree*))\r\n\r\n         (map? @my-tree*)     (doall (map  (fn [[key item]]\r\n                                             [map-tree-node {:tree* my-tree* :key key}]) @my-tree*)))]))))\r\n\r\n\r\n\r\n(comment (defn tree-widget [props]\r\n           (let [{:keys [tree* index compilation-rules]} props]\r\n             (r/with-let [my-tree* (r/cursor tree* (if index index []))\r\n                          expanded* (r/atom true)]\r\n     ; expanded is for the entire component, BUT \r\n     ; we use a map to create multiple subtrees, and each needs its own \"expanded*\"\r\n     ; should move expanded* to separate sub components\r\n               [:div\r\n                [:div {:class \"tree-node\"}\r\n                 (cond\r\n                   (not (coll? @my-tree*)) [:div {:class \"inner-tree-value\"}  @my-tree*]\r\n                   (vector? @my-tree*) [:div (doall (map-indexed (fn [index item]\r\n                                                                   [:div\r\n                                                                    [:div {:class \"inner-tree-value\"\r\n                                                                           :style {:cursor \"pointer\"}\r\n                                                                           :on-click (fn [] (swap! expanded* not))} (str index (if @expanded* \" V\" \" >\"))]\r\n                                                                    (if @expanded*\r\n                                                                      [tree-widget  {:key index :tree* my-tree* :index [index]}])]) @my-tree*))]\r\n\r\n                   (map? @my-tree*)    [:div (doall (map (fn [[key item]]\r\n                                                           [:div [:div {:class \"inner-tree-value\"\r\n                                                                        :style {:cusror \"pointer\"}\r\n                                                                        :on-click (fn [] (swap! expanded* not))} (str key (if @expanded* \" V\" \">\"))]\r\n                                                            (if @expanded* [tree-widget  {:key (str \"map\" index) :tree* my-tree* :index [key]}])]) @my-tree*))]\r\n                   :else\r\n                   (js/alert \"Not supported \" @tree*))]]))))\r\n\r\n\r\n\r\n(defn tree-widget [props]\r\n  (let [{:keys [tree* index]} props]\r\n    (r/with-let [my-tree* (r/cursor tree* (if index [:tree index] []))\r\n                 indicators* (r/cursor my-tree* [:indicators])]\r\n      (let [{:keys [id class value component indicators]} @my-tree*]\r\n        [:div {:class (str \"tree-node \" class)}\r\n         [:div {:class \"inner-tree-value\"}\r\n          (if (not (contains? #{:vector :map} (:type @my-tree*)))\r\n            (vec (concat\r\n                  [:<> (map-indexed (fn [c-index c]\r\n                                      [c {:tree* my-tree* :value value :indicators* indicators* :key (str id c-index)}]) component)])))]\r\n\r\n         (if (:expanded @indicators*)\r\n           [:div {:class \"inner-tree-children\"}\r\n            (vec (concat\r\n                  [:<> (map-indexed (fn [index child-node]\r\n                                      [tree-widget {:class (str \"child-\" index)\r\n                                                    :index index\r\n                                                    :key (str \"comp\" id index)\r\n                                                    :tree* my-tree*}]) (:tree @my-tree*))]))])]))))\r\n\r\n\r\n(defn node [props]\r\n  (r/with-let [expanded* (r/atom false)]\r\n    (let [{:keys [tree-options value nodes type style expanded-style class expanded-class]} props]\r\n      [:div (merge\r\n             {:class class}\r\n             {:style style}\r\n             (case type\r\n               :click {:on-click (fn [e]\r\n                                   (. e stopPropagation)\r\n                                   (swap! expanded* not))}\r\n               :hover {:on-mouse-enter #(reset! expanded* true)\r\n                       :on-mouse-leave #(reset! expanded* false)}\r\n               (:events props)))\r\n       \r\n       value\r\n       (if @expanded*\r\n         (let [child-count (count nodes)]\r\n           [:div {:style expanded-style\r\n                  :class expanded-class}\r\n            (map-indexed (fn [index child]\r\n                           [:<> {:key (:id child)}\r\n                            [node (merge {:tree-options tree-options} child)]\r\n                            (if (not= index (dec child-count))\r\n                              [:div {:class (:separator-css tree-options)}])])\r\n                         nodes)]))])))\r\n  \r\n"]}